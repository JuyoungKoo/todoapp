# 공부 일지

작성값 : 날짜, 커밋 A(날짜, 제목) - 커밋 B(날짜, 제목)

cherry-pick 으로 필요한 부분만 가져와서 운영 반영

## 2021.10.26

### 서버란?

클라이언트의 요청을 받으면 서비스, 데이터를 제공하는 컴퓨터 혹은 프로그램
요청을 받으면 데이터를 보내주는 기계

서버 코드 예시 : if 누군가가 OO페이지 요청을 하면 OO페이지 html을 보내줌.

### 서버에 요청할 수 있는 4가지 방법

웹서버에 유저가 정식으로 할 수 있는 요청은 4 종류가 있다.

1. GET(읽기요청) : 웹 페이지를 읽을 때
2. POST(쓰기or생성요청) : 글쓸 때, 로그인할 때
3. PUT(수정요청) : 글이나 댓글 수정
4. DELETE(삭제요청) : 글이나 댓글 삭제

GET 요청을 하는 가장 쉬운 방법은 바로 브라우저 주소창에 URL을 입력하는 것.
브라우저의 URL입력란이 바로 GET 요청하는 곳이다.
BUT  URL을 외우는건 어렵기 때문에 웹개발자들은 버튼을 누르면 URL 이동을 할 수 있게 HTML을 짜놓는 것.

### Node.js

HTML : 웹페이지를 만들 때 사용하는 언어.
JavaScript : 웹페이지를 움직이게 만들 때 사용하는 언어.
Node.js : 자바스크립트 해석엔진인 V8이라는 프로그램을 만들었는데 성능이 뛰어나 이것만 떼어 살을 붙여 출시한 것.
Node.js란 자바스크립트를 브라우저 말고도 로컬 PC에서도 실행시켜줄 수 있는 실행창(런타임)이다.
Node.js는 요청이 차례로 들어왔을 때, 접수를 다 받고 빨리 완료된 것부터 처리해준다. Event Loop (동작 원리)

### 서버를 띄우기 위해 작성할 기본 템플릿

(server.js 파일)

const express = require('express');
const app = express();

app.listen(8080, function() {
    console.log('listening on 8080')
})

이렇게 쓰면 서버가 뜬다. 첫 두줄은 express 라이브러리 첨부와 사용. 밑에 app.listen()은 원하는 포트에 서버를 오픈하는 문법.
listen() 함수 안엔 두개의 파라미터가 필요.  listen(서버를 오픈할 포트번호, function(){서버 오픈시 실행할 코드}) 이렇게 사용. 
위 코드를 작성하고 터미널에서 node server.js 입력하면 서버가 뜸. 브라우저에서 localhost:8080 접속하면 확인 가능.

### 포트

컴퓨터는 외부와 통신할 수 있는 구멍이 60000개 정도 있다. 이걸 포트라고 부른다. 

### 콜백함수

function(){} 이라는 문법은 자바스크립트로 함수를 하나 만들겠다~ 라는 뜻

위 코드를 보면, 
.listen(서버를 오픈할 포트번호, function(){서버 오픈시 실행할 코드})
이렇게 되어있다. 
위의 예제 코드에선 함수명을 작명하는 부분이 없고 function(){} 이렇게 사용하고 있고,
listen()이라는 함수 안에 함수를 집어넣는 형태로 사용,
이걸 자바스크립트에선 '콜백함수'라고 부른다. 
정의는 함수안에 들어가는 함수 이다.
콜백함수를 왜 쓰냐면.. 자바스크립트에서 뭔가 순차적으로 실행하고 싶을 때 사용한다고 알 것
listen() 이라는 함수를 동작시킨 다음에 function(){} 내에 있는 코드를 실행해주세요~ 라는 뜻으로 사용
Node.js 특성상 코드를 연달아서 2개 적는다고 그 코드가 순차적으로 실행된다는 보장이 없기 때문에 뭔가 순차적으로 실행할 때 '함수안에 함수를 집어넣는 콜백함수'를 꼭 사용
순차적 실행이 목적이고 이 패턴을 눈에 익혀두시면 이제 서버만들 때 문법적으로 어려운게 전혀 없다.

### GET 요청시 HTML 파일을 보내주도록 하기.

1. HTML 파일이란? 웹페이지를 구성하는 언어. 그림 넣고 글씨 쓰고 예쁘게 꾸민 파일.

### Bootstrap (부트스트랩)  --> 빠르게 HTML UI 개발 --> Tailwind CSS도 알아볼 것

    - 트위터 사내 개발자들이 만든 웹 컴포넌트 라이브러리
    - 기존의 HTML CSS 디자인하고 메뉴만들고 하던 작업의 시간을 줄여주는 라이브러리
    - 구글 "Bootstrap" 검색 후 사이트 방문 -> Get started 메뉴 -> starter template라는 부분 코드 -> index.html에 적용
    - https://getbootstrap.com/docs/4.4/getting-started/introduction/#starter-template
    - 연습 때는 CSS파일 등을 직접 다운받아서 설치하지 않고 CDN 방식으로 했음. CSS 파일 다운 받아서 해볼 것.
    - npm 으로도 Bootstrap 설치 가능.

### 2021년 이후 설치한 프로젝트들은 body-parser 라이브러리가 express에 기본 포함이라 따로 npm으로 설치할 필요가 없음.

    - app.use(express.urlencoded({extended: true}))  
    - 이 코드만 위쪽에 추가해주면 된다.

### 콜백함수

1. 함수는 그냥 function 함수 (){} 이렇게 만든다.
2. 함수를 사용할 때 파라미터자리에 함수도 집어넣을 수 있다.
3. 예를 들면 get 함수를 쓸 때 계속 그래 왔다.
    - app.get(어쩌구, function(){} );
    - get도 소괄호를 뒤에 붙이는걸 보면 함수가 맞는데, get함수를 쓸 때 소괄호 내에 또 function(){} 이라는 함수를 집어넣고 있다.
    - 함수안에 들어가는 함수를 바로 콜백함수라고 부른다.
    - 자바스크립트에서는 순차적으로 실행하고 싶을 때 콜백함수를 이용한다.

    - app.get('/write', function(){어쩌구} );
    - 누군가 /write로 요청하면 콜백함수 내부의 어쩌구라는 코드를 실행해주세요~ 라고 순차적으로 기능을 실행할 때 많이 사용한다.
    - express 문법에 따라서 콜백함수 넣어서 써라 하면 콜백함수 넣어서 쓰면 된다.

    - app.get('/write', ( ) => { 어쩌구 } );
    - function 이라는 키워드 대신 => 라는 화살표를 이용 가능하다. (위치는 소괄호 오른쪽!! 주의)
    - ES6라고 부르는 자바스크립트 신문법. 콜백함수를 만들 때 코드가 간단해질 수 있어서 선호된다.
    - 함수 내부에서 this라는 키워드의 값이 바뀐다는 특징이 있는데 보통 상황에선 전혀 신경 쓸 필요없으니 자유롭게 사용하면 된다.

#### API란?

    - Application Programming Interface
    - 서로 다른 프로그램간에 소통할 수 있게 도와주는 통신 규약
    - 웹에서는 '서버와 고객간의 통신 규약'  -->  '서버에게 요청해서 데이터 가져오는 방법'
    - 지금까지 한 코딩이 /write 로 접속하면 write.html을 보내줘 같은 것. 바로 이게 서버의 API이다. 
    - 즉, write.html을 보고싶으면 /write로 접속할라는 API를 정의한 것.

#### REST API란?

    - Representational State Transfer
    - 웹 API 짤 때 REST 원칙을 지켜서 짜면 좋다 라고 하는데 총 6개의 원칙이 있음.

1. Uniform Interface 
    - 인터페이스는 일관성이 있어야한다
    - 하나의 URL로는 하나의 데이터를 가져와야함 (하나를 가져오기 위한 두개의 URL을 만들지 말자)
    - 간결하고 예측가능하게 짜야한다 (URL 하나를 알면 둘을 알게)
    - URL 이름짓기 관습을 잘 따라야 한다. 
    - URL 대신 URI 용어를 많이 쓰기도 하는데, URI는 자료를 넘버링하고 분류하고 지칭하는 방법. 도서관 책분류할 때 URI에 의해 분류하기도 한다.

2. Client-server 역할 구분하기
    - 고객들은 URL 하나만 알면 서버에 있는 자료를 갖다쓸 수 있다.
    - 고객에게 서버역할을 맡기거나, DB에 있는 자료를 직접 꺼내라고 하는 식으로 코드를 짜면 안된다.

3. Stateless
    - 요청들은 각각 독립적으로 처리되어야 한다.
    - 요청1이 성공해야 요청2를 보내주는 식의 요청간 의존성이 존재하는 코드를 짜면 안된다.
    - 요청하나 만으로 자료를 가져오기 충분하도록 요청에 필요한 모든 정보들을 실어 보내는게 좋다는 뜻.

4. Cacheable
    - 요청을 통해 보내는 자료들은 캐싱이 가능해야한다.
    - 그리고, 캐싱가능하다고 표시하거나 캐싱 기간을 설정해주여아 한다
    - 캐싱이란? 네이버 방문시 크롬 브라우저는 자동으로 자주 사용하는 이미지 파일, CSS 파일 등을 하드에 저장해놓는다. 별로 바뀔일 없는 네이버 로고나 아이콘 등.
      하드에 저장해놓고 네이버 방문할 때 네이버서버에 네이버 로고주세요 라고 요청하지 않고 하드에서 불러온다. 이 행위를 캐싱이라고 한다.

5. Layered System
    - 요청처리하는곳, DB에 저장하는곳 이런 여러가지 단계를 거쳐 요청을 처리해도 된다.
    - 여러개의 레이어를 거쳐서 요청을 처리하게 만들어도 된다고 한다.

6. Code on Demand
    - 서버는 고객에게 실제 실행가능한 코드를 전송해줄 수도 있다.

#### URL 이름짓기 관습

    - instagram.com/explore/tags/kpop
    - instagram.com/explore/tags/food
    - facebook.com/natgeo/photos
    - facebook.com/bbc/photos

    - 이 URL들은 페이스북이 매우 잘만든 API이다.
    - 왜냐하면, facebook.com/bbc/photos는 딱봐도 BBC뉴스 페북계정의 사진첩인 느낌이 들기 때문이다.

    - 단어들을 동사보다는 명사 위주로 구성함.
    - 응용해서 다른 정보들을 쉽게 가져올 수 있을 정도로 일관성 있음
    - 대충 봐도 어떤 정보가 들어올지 예측이 가능함.

    - 띄어쓰기는 _(언더바) 대신 -(대시) 기호 사용
    - 파일 확장자 쓰지 말기 (.html 이런거)
    - 하위 문서들을 뜻할 땐 / 기호를 사용함 (하위폴더 같은 느낌)

    - 서버 API 중에 "/add로 POST 요청을 하면 ~ 해주세요" 를 "/newpost로 POST 요청을 하면 ~해주세요" 이렇게 명사로 바꾸면 더 REST 해진다.

#### MongoDB 셋팅하기

    - Database Access 메뉴에서 DB 접속용 아이디/비번을 생성한다.
    - 데이터베이스 접속할 수 있는 아이디/비번을 새로 만들어주는 것. [admin/qwer1234]

    - Network Access 메뉴에서 IP를 추가
    - 데이터베이스 접속할 수 있는 IP를 미리 정의해놓는 일종의 보안장치
    - Allow access from anywhere을 누르시거나 0.0.0.0/0 을 추가

    - Databases --> Browse Collections. collection 만들기를 진행 (Add My own Data -> 데이터베이스 설정 및 생성)
    - Cluster는 하나의 호스팅 공간. 그 안에 데이터베이스를 만들어야 데이터를 저장할 수 있다.
    - 이 데이터베이스를 내 컴퓨터에서 접속하려면 접속 URL을 코드에 복붙해주면 된다.
    - 접속 URL에는 내 디비 접속용 아이디/비번/데이터베이스 이름이 들어가야 한다.

    -접속 URL 복붙하실 때 mongodb+srv://디비계정아이디:디비계정패스워드@cluster0-qaxa3.mongodb.net/데이터베이스이름?retryWrites=true&w=majority
    이거 3개를 잘 입력해야합니다. (server.js 참고)

#### Database

    - 데이터를 일정한 형식으로 저장할 수 있게 도와주는 곳 (가장 쉽게 볼 수 있는게 엑셀) (엑셀에서 시트를 하나 만든 후 행과 열에 원하는 데이터를 기입하면 자료 저장 끝 처럼 데이터베이스도 동일)
    - 데이터베이스는 SQL이라는 언어를 써서 데이터를 입력, 출력 한다.

    - BUT MongoDB는 NoSQL
    - 처음 다룰 때 어려운 셋팅작업 없음 (스키마 생성 등)
    - SQL문 쓰지 않음
    - 평생 무료 호스팅해주는 곳이 있음

    - server.js에서 DB에 접속하기위한 접속 방법
    - mongodb main 화면에서 connect 버튼 누르기 -> 가운데 Connect Your Application 버튼 누르기 -> 
    - (1) Choose your driver version 에서 Node.js 선택되어있는지 잘 확인하기 -> (2) 밑에 접속 URL(Connection String) 긴게 뜨면 복사해서 일단 메모장 같은 곳에 저장해놓기
    - 접속 URL만 잘 써주면 이제 Node.js로 돌아가는 파일에서 내 DB와 직접 통신이 가능.

    - server.js에서 DB에 접속하려면
    1. 터미널 켜서 npm install mongodb 를 입력해 라이브러리 설치한다.
    2. server.js 상단에 다음 코드를 추가한다 : const MongoClient = require('mongodb').MongoClient;  require라는 글자 많은 곳에 함께 위치시켜 줄 것.
    3. 하단에 MongoClient.connect()~ 추가. (server.js 참고)

#### Database에 자료 저장하는 방법

    - 사용자가 /add로 POST 요청을 하면 폼에 입력된 자료를 2개가 서버로 도착한다.
    - 이 때 자료 2개를 post라는 이름의 collection에 저장해보도록 하자.
    - { 제목:'123', 날짜'456'} 이런 Object 자료형으로 저장하면 된다.

#### 자료를 저장하기 위해선 먼저, MongoDB에 저장할 폴더와 파일을 만들자.

    - 위의 접속 URL 길게 적어서 쓴건 내 계정에 접속하는 것.
    - 계정 안에 있는 여러가지 database와 collection에 자료를 저장해보자.

#### database / collection 만들기

1. MongoDB Atlas 메인 대시보드에서 Collections 라는 버튼을 누르도록 합시다.
2. Add my own data  버튼을 누르자. (혹은 이미 뭐가 있다면 creat database)
3. database 이름, collection 이름을 하나씩 정해준 다음 저장. (예를들어, database이름은 todoapp collection이름은 post로 저장)
4. ----------------database----------------
    collection             collection
   ----------------------------------------
5. database는 하나의 폴더, collection은 하나의 엑셀파일이라고 생각하기

#### collection에 자료 추가하는 방법

1. db.collection('post') 라는건 collection 중에 post라는걸 선택한다는 뜻이고, 뒤에 .insertOne을 붙이면 자료를 추가할 수 있다. (Object 자료형식으로 추가가능)
2. inserOne 함수는 insertOne(추가할자료, 콜백함수) 이렇게 쓰면 된다.
3. db.collection('post').insertOne() 이 패턴을 잘 기억하기. 데이터 추가하고 삭제하고 수정할 때도 이와 동일한 형식이다. 서버 개발은 이해보다 패턴 외우는게 중요하다.
4. 몇줄에 걸친 긴 코드를 합쳐서 한번에 작성 하면, client.db('todoapp').collection('post').insertOne(추가할 자료, 콜백함수) 이렇게 된다.

#### HTML에 DB데이터 꽂아 넣는 법 (EJS)

1. /list 로 방문하면 ejs 파일을 보내주자
2. 그냥 HTML 파일만 보내주면 흔히 말하는 Static페이지가 된다.
3. HTML에 실제 DB데이터를 넣어서 보내줄 수 없다. 그래서 EJS, Pug같은 템플릿 엔진을 사용한다.
4. EJS는 서버 데이터를 HTML에 쉽게 박아 넣을 수 있게 도와주는 일종의 HTML 랜더링 엔진이다.
5. EJS를 이용해서 DB데이터를 HTML에 박아넣어보도록 하자. 

#### EJS 파일 만들기

1. EJS 파일은 그냥 html과 똑같이 만들어 쓰면 된다.
2. 중간중간 EJS 문법으로 데이터를 꽂아넣는다.
3. EJS를 사용하면 HTML에 여러가지 자바스크립트 문법을 사용가능하다.

#### EJS 파일 기본 문법

    - <h2><%= user.name %></h2>
    - HTML 중간중간에 서버 데이터를 집어넣고 싶을 땐 이렇게 사용한다.  <%= 서버에서 보낸 데이터의 변수명 %>
    - 그럼 HTML 글자로 렌더링 된다.

    - <% if (user) { %>    <h2><%= user.name %></h2>  <% } %>
    - HTML에 if문을 적용하거나 반복문을 적용하고 싶을 땐 <% %> 내부에 자바스크립트 문법을 담으면 된다.
    - 위의 예시 코드는 user라는 변수가 참일 때만 내부 <h2>코드를 보여줄 것.
    
    - EJS 안에서 자바스크립트 문법을 쓸 때 <% %> 내부에 담아야 한다.

#### 코드 작성 흐름 정리

1. 사용자가 /list로 GET 요청을 하면,
2. MongoDB에서 데이터를 꺼낸뒤,
3. list.ejs 파일에 그 데이터를 꽂아넣어서 사용자에게 보내줌.

#### MongoDB에서 데이터를 꺼내고 싶을 때

    - db.collection('post').find() 
    - db.colleciton('post').findOne()
    - 이런 식으로 쓰면 데이터를 꺼낼 수 있다.
    - db.collection('post').find().toArray() 라고 적으면 collection('post')에 있는 모든 데이터를 Array 자료형으로 가져온다.

#### 관계형(Relational) 데이터베이스  vs  NoSQL 데이터베이스

1. 관계형 데이터베이스
    - 엑셀처럼 행과 열로 데이터를 저장할 수 있는 데이터베이스
    - 엑셀의 시트처럼생긴 테이블이라고 부르는 공간을 하나 생성한 후, 행과 열에 맞춰 데이터를 저장한다.
    - 범용적이다. 구조화된 데이터 저장에 좋다. 
    - SQL이라는 언어를 이용해 데이터를 출력 입력 한다.
    - "이 열엔 숫자가 들어온다~"와 같은 스키마를 미리 정의하기 때문에 관리가 쉽다.
    - 구조화된 데이터 덕분에 원하는 데이터 뽑기도 쉽다.
    - 트랜잭션, 롤백 기능을 이용해 데이터의 무결성을 보존하기 쉽기 때문에 금융, 거래 서비스에 필수.

2. NoSQL 데이터베이스
    - SQL문 없이도 사용할 수 있는 데이터베이스
    - 테이블에 국한되지 않고 자유로운 형식으로 데이터를 쉽게 분산저장할 수 있다.
    - key-value 모델 : Object, JSON 자료형 형식으로 데이터를 쉽게쉽게 저장, 출력이 가능하다. 가장 심플하다.
    - Document 모델 : 테이블 대신 Collection이라는 문서 기반으로 데이터를 분류하고 저장한다. 테이블보다는 훨씬 유연하다.
    - MongoDB도 key-value, Document 모델 저장방식을 차용하고 있다.
    - 대량의 데이터를 빠르게 입출력할때 NoSQL이 제격이다.
    - 자바스크립트 object{} 자료형 다루듯이 데이터를 입출력할 수 있으니 편리하다.
    - 서버에서 쓰던 프로그래밍 언어로 DB를 다룰 수 있다.
    - 스키마 정의 없이도 쉽게 쓸 수 있음. (이 열의 데이터는 정수이다~ 라는 표현 안해도 된다.)
    - NoSQL 데이터베이스는 기본적으로 SQL에서의 JOIN연산을 적용하는게 어렵다. 서버 단에서 JOIN 연산을 쉽게 처리해주는 라이브러리를 이용한다.

#### AJAX를 써서 삭제요청 하기.
    - 요청은 4개 종류가 있다 : GET / POST / PUT / DELETE
    - HTML 폼에서 일반적으로 PUT DELETE 요청을 할 수 없다. (HTML이라는 언어를 만들 때 잘못 만든 것)
    - 삭제요청을 할 때 쓸 수 있는 3가지 방법
        1. method-override 라이브러리의 도움을 받는다
        2. AJAX로 DELETE 요청을 날린다
        3. 그냥 POST 요청을 날려서 DELETE 작업을 수행한다 (POST로 삭제 요청해도 전혀 상관없다. BUT REST한 API를 만들기 위해 1,2번을 사용한다)

#### AJAX
    - 프론트앤드에서 JavaScript를 이용해서 서버에 여러가지 요청을 할 수 있는 문법같은 것.
    - 장점은 새로고침 없이도 서버에 몰래몰래 요청을 할 수 있다.
    - 새로고침 없이 스무스한 사이트 만들고 싶으면 많은 요청을 AJAX 문법을 이용해 처리하게 된다.
    - AJAX를 사용해서 개발하면 삭제 버튼을 누르는 순간 새로고침 없이도 글 삭제가 가능하다.

#### AJAX를 쓰기 위한 jQuery 설치
    - 쌩 자바스크립트로도 AJAX가 가능하지만 코드가 길어서 정신건강을 위해 jQuery를 설치한다.
    - <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="어쩌구" crossorigin="어쩌구" ></script>
    - 이 코드가 jQuery를 CDN 방식으로 설치하는 부분
    - CDN은 다른 사이트에서 호스팅해주는 jQuery 파일을 내 HTML에 적용해달라는 뜻
    - 하지만 그냥 쓸 수 없다. jQuery Slim 버전인데 이걸로  AJAX요청이 불가능하다.
    - <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    - 수정해준다. 1. slim이라는 글자를 지우고, 2. 뒤에 있는 이상한 글자들을 제거한다.
    - 이렇게 써주어야 정상적으로 AJAX 기능이 들어있는 jQuery 라이브러리를 설치할 수 있다.

#### 고객 요청에 응답하는 방법

app.get('/어쩌구', function(요청, 응답){
  응답.send('<p>some html</p>')
  응답.status(404).send('Sorry, we cannot find that!')
  응답.sendFile('/uploads/logo.png')
  응답.render('list.ejs', { ejs에 보낼 데이터 })
  응답.json(제이슨데이터)
});

    - send는 간단한 문자나 HTML을 보낼 수 있다.
    - status는 응답코드를 보낼 수 있다. (서버에러일 경우 500, 이상한 요청일 경우 400)
    - sendFile은 static 파일들을 보낼 수 있다.
    - render는 ejs등의 템플릿이 적용된 페이지들을 렌더링해줄 수 있다.
    - json은 제이슨 데이터를 담아보낼 수 있다.
    
### nav.html

    - 페이지 마다 <nav>태그로 이루어진 상단메뉴 UI가 계속 출현하고, 이 UI는 전부 같은 모습을 하고 있다.
    - 수정사항이 생기면 페이지마다 해주면 오래걸리므로 nav.html 파일을 하나 만들고 그 파일을 다른 파일에다가 include(첨부)하는 식으로 UI를 만들기

#### edit.ejs

    - 수정기능을 구현하기 위해 만든 페이지.
    - write 페이지를 그대로 쓰는데 전송시 'post'가 아니라 '수정'요청으로 바꾸는 경우도 있을 수도 있다.
    - write.ejs 전부 복붙 후, 새로운 점은 input 태그에 value 속성을 집어넣어야 한다는 것이다.
    - <input type="text" value="111111"> 
    - input 태그에 이렇게 value 속성을 집어넣으시면 input태그에 미리 채워진 값을 설정할 수 있다.
    - 이 자리에 원래있던 제목이나 날짜데이터를 넣어주면 수정하기 편하겠지?

#### Session-based Authentication

    - 사용자의 세션정보를 저장해서 로그인 기능을 구현하는 방법입니다. 
    - 이 사람이 로그인 했었다는 정보를 서버의 메모리에다가 기록해놓습니다. (세션을 저장합니다.)
    - 그리고 고객이 로그인이 필요한 페이지(Mypage 등)를 요청을 하면 세션을 들춰봐서 이 사람이 로그인했다는 정보가 나오면 통과시켜줌~!

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 서버는 옳다구나 하고 세션스토어에 세션 하나를 만들어서 저장합니다. 
   세션은 용어가 어려워서 그렇지 그냥 이 사람이 언제 어디서 로그인 했는지 이런 정보를 담은 자료라고 보시면 됩니다.
   "Kim 이라는 사람이 7시에 로그인했습니다."  뭐 이런 정보를 서버 메모리에 저장해둡니다. 

2. 그리고 로그인한 유저마다 각각 유니크한 세션아이디라는걸 발급합니다. 
   당연히 로그인한 사람이 여러명일 수 있으니 유니크한 세션아이디를 발급해서 구분지어주는게 좋겠죠.
   그래서 abc123 이라고 세션아이디를 하나 예쁘게 발급해줬습니다. 

3. 발급한 세션아이디는 쿠키에 담아서 고객 브라우저에 전송해줍니다. 
   세션아이디는 고객과 서버 둘다 보관합니다. 그래서 쿠키에 담아서 고객에게 보내줍니다.
   쿠키란 브라우저에 마련되어있는 쪼그만한 문자데이터 저장공간입니다. 여기에 세션아이디가 abc123 이렇게 기록됩니다. 
   여기까지가 로그인 기능 구현 끝입니다. 

#### 고객에 로그인이 필요한 페이지를 요청한 경우, 이 사람이 적법하게 로그인 했던 사람인지 검사

1. 고객이 로그인합니다. 아이디 / 비번을 서버로 전송하면 서버는 기존에 있던 DB에 아이디/비번 세트가 존재하면 옳다구나 하고 세션아이디를 만들어줍니다. 
   그리고 세션아이디들을 담을 변수나 뭐 DB 공간을 마련해서 거기 저장해둡니다. 그걸 세션데이터라고 부릅시다. 
   (저장은 DB에 할 수도 있고 서버 메모리(그냥 변수)에 저장할 수 있습니다. )
   그리고 세션 아이디를 쿠키라는 것에 이쁘게 포장해서 고객의 브라우저에 쿠키를 강제로 저장시킵니다. 

2. 고객이 마이페이지를 요청합니다. 
   /mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 
   "님 로그인 했었음?" 이라고 물어봐야하니까요. 물어보는 과정은 심플합니다. 

3. 쿠키에 세션아이디가 포함되어있는지 검사합니다. 
   원래 고객이 페이지를 요청할 때 마다 자동으로 쿠키가 서버로 전송됩니다.
   그럼 서버는 쿠키에 기록된 세션아이디를 서버메모리 or DB에 저장되어있던 세션아이디와 비교해서 있으면 통과시켜줍니다. 

4. 서버는 마이페이지를 보내줍니다. 
   그 전에 이 회원의 이름, 나이, 성별 등의 DB 정보가 필요하다면 세션데이터를 참고해서 이 사람의 이름, 나이 등의 정보를 DB에서 꺼내옵니다. 

실은 로그인기능 구현 그거 별거 아닙니다. 
아이디/비번을 DB에 기록할 수 있는 회원가입 폼 알아서 만들어두시고 (진심 별거아님)
어떤 사람이 로그인하면 세션아이디를 하나 발급해서 서버와 고객이 나눠가집니다. 
그리고 고객이 마이페이지같은거 요청할 때마다 "니 세션아이디 뭔데" 라고 물어보면 됩니다. 
세션은 매우 전통적이고 범용적으로 사용되는 인증방식입니다. 
그러므로 여러분이 개발 중 위기에 처했을 때 참고할 구글 검색결과가 풍부합니다. 

#### JSON Web Token (JWT)

    - 토큰 방식은 세션데이터를 서버에 저장하지 않고 마이페이지를 열람할 수 있는 열쇠(토큰)를 사용자에게 쥐어주는 것입니다. 
    - 그래서 그 열쇠에는 session방식보다 약간 더 많은 정보들이 들어갑니다. 
    - 요즘 토큰토큰 거리면 JSON Web Token을 말하는 것인데, 아무튼 어떤 방식인지 자세히 알아보도록 합시다. 

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 서버는 옳다구나 하고 Token 하나를 만들어서 고객 브라우저로 보내줍니다. 
   Token은 그냥 긴 암호화된 문자열일 뿐이고, 사용자가 로그인 했었는지, 아이디는 무엇인지 이런 정보들을 넣을 수 있습니다. 
   물론 위조가 불가능하도록 특별한 서명이 추가됩니다. 
   토큰은 쿠키나 로컬스토리지라는 곳에 저장됩니다. 
   (+ 코드를 잘 짜서 고객이 페이지 방문시마다 Token이 서버로 보내지도록 미리 장치를 추가합니다. )

2. 고객이 마이페이지를 요청하면 /mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 
   "님 로그인 했었음?" 이라고 물어봐야하니까요.
   물어보는 과정은 그냥 토큰 검사입니다. 

3. 서버는 토큰을 검사합니다
   고객이 마이페이지 요청시 함께 보낸 Token이 적법한지 검사합니다. 
   유통기한이 지나지 않았는지, 서명이 잘 되어있는지, 블랙리스트에 등록된 토큰인지 이런 검사를 거친 후 이상이 없으면 마이페이지로 통과시켜줍니다.

기본적인 토큰 구현은 매우 간단합니다.
그리고 서버는 세션데이터 등을 메모리/DB에 저장해둘 필요가 없으니 나중에 서버 스케일링시 큰 문제가 없다는 장점도 있습니다. 
하지만 단점이나 보안상 취약점이 존재할 수 있습니다.
이 사람이 로그인 했는지에 대한 정보 전체를 서버는 가지고 있지 않고 사용자가 가지고 있게 하는 것 자체가 보안상 좋은 방법은 아닙니다.
JWT 정보를 다른 사람이 훔치면 어쩔 것임? 이제 훔친 사람은 자유롭게 로그인이 가능하겠는데요? 
그래서 stateful JWT 라고 부르는 '어떤 사람이 언제 로그인했는지'를 서버에 저장해두는 방식이 좋은 관습이긴 한데 그 중 하나가 refresh token 이런 방식입니다.  
그러면 위에서 말했던 세션 방식이랑 기능 상 다를바가 없습니다. 

#### Open Autentication

이 방법은 쉽게말하면 페이스북, 구글 로그인입니다.
고객의 페이스북, 구글 계정정보를 불러와서 그걸 가지고 가입을 승인시켜주는 방법입니다.  
간략히 어떻게 작동하는지 구경해봅시다. 

1. 어떤 사람이 '페이스북으로 로그인' 버튼을 눌렀다고 칩시다. 
   그럼 페이스북 팝업이 뜹니다. 
   "코딩애플 앱에 본인의 페이스북 이름, 아이디 제공을 승인하시겠습니까?"
   승인을 눌러봅니다. 

2. 그럼 페이스북은 우리 server.js에게 이 유저의 이름, 아이디 정보를 보내줍니다. 
   그럼 뭘 해야할까요. 여러분이 하고싶은거 하시면 됩니다.

3. 이 사람 페이스북 정보를 바탕으로 세션이나 토큰을 만들어줍니다. 
   DB에 이름, 아이디를 저장해서 회원 목록을 하나 만들어주든가,
   그와 동시에 세션 데이터를 만들어주든가 하시면 됩니다. 
   server.js에 코드를 잘 짜서 하면 되겠죠.

4. 고객이 마이페이지를 요청하면 /mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 
  "님 로그인 했었음?" 이라고 물어봐야하니까요.

5. 서버는 토큰이나 세션을 검사합니다
   위에서 세션을 만들어 줬다면 세션이 있는지 검사하면 되고, 위에서 토큰을 만들어 줬다면 토큰이 적법한지 검사하면 되겠죠?
   통과되면 마이페이지를 응답.render() 해줍니다.

비밀번호를 취급안해도 된다는 장점 때문에 관리도 편리하고 유저도 편리함을 느낍니다. 
페이스북 등에서 제공하는 공식 개발문서가 많기 때문에 따라하기만 하면 일사천리로 개발이 가능합니다. 
하지만 단점은 구글이나 페이스북이 1. OAuth를 중단하거나 2. 방법을 수정하거나 3. 페이스북 API 서버 다운으로 접속이 불가능하다면
우리 사이트 로그인도 불가능합니다. 
페이스북은 맨날 OAuth 방법이나 정책 이런걸 변경했다고 메일자주보내는데 그래서 약간 관리하기 귀찮은 면도 있습니다. 

#### (회원인증기능 1) 로그인 페이지 만들기 & 아이디 비번 검사

1. 일단 로그인 & 세션생성을 도와줄 라이브러리 설치가 필요합니다. 
   npm install passport passport-local express-session
   을 터미널에 입력해서 설치하도록 합시다. 
   저렇게 띄어쓰기로 동시에 3개 라이브러리를 설치하시면 됩니다. 
   로그인, 로그인 검증, 세션생성을 도와주는 라이브러리 들입니다. 
   (실제 서비스시 express-session 말고 MongoDB에 세션데이터를 저장해주는 라이브러리를 이용하시면 좋습니다.)

2. server.js 상단에 설치한 라이브러리를 require 해줍니다. 
   그래야 설치한 것들을 사용할 수 있으니깐요. (라이브러리 사용법에 이렇게 나와있는거 그대로 작성한 것입니다)

            const passport = require('passport');
            const LocalStrategy = require('passport-local').Strategy;
            const session = require('express-session');

            app.use(session({secret : '비밀코드', resave : true, saveUninitialized: false}));
            app.use(passport.initialize());
            app.use(passport.session()); 
   이렇게 6줄이 필요합니다. 대소문자 틀리면 코딩인생이 끝날 수 있기 때문에 대소문자 잘 구분하십시오. 

잠깐 문법설명을 하나 드리자면 app.use() 어쩌구 부분은 '미들웨어를 쓰겠다'라는 뜻입니다. 
미들웨어가 뭐냐면..
서버는 요청을 받으면 응답을 해주는 기계랬죠?
그런데 요청과 응답 사이에 뭔가 실행시키는 코드들이 바로 미들웨어입니다. 
뭐.. 요청이 적법한지 검사하는 그런 기능들을 미들웨어에 많이 담습니다.
미들웨어를 어떻게 쓰냐면.. app.use 안에 담는 코드들은 전부 미들웨어 역할을 할 수 있습니다. 
그러니깐 위에 있는 코드 중에 passport.initialize() 그리고 passport.session() 이런 코드들이 모든 요청과 응답 중간에 실행된다는 뜻입니다. 
나중에 미들웨어를 직접 하나 만들고 싶다면 그것도 가능합니다.
그냥 app.use() 안에 집어넣어주시면 되겠습니다. 

<개발 흐름>
어떤 사람이 로그인을 해주면 일단 그 사람의 아이디와 비번이 DB에 있는 아이디와 비번이 맞는지 검사해야합니다. 
그리고 검사 결과가 맞으면 세션을 하나 생성해주고 성공페이지로 이동시키기,
실패하면 실패페이지로 이동시키기 입니다. 

#### 주영이 공부일지
